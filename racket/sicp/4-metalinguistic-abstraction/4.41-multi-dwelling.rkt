(list (amb '(1 2 3) (lambda (x)
                      (list x (amb '(a b))))))
((1 a) (1 b) (2 a) (2 b) (3 a) (3 b))

(define (amb choice-lst)
  (define (next)
    (if (null? choice-lst)
        '()
        (let ((x (car choice-lst)))
             (set! choice-lst (cdr choice-lst))
             x)))
  (define (dispatch msg)
    (case msg
      ('next (next))
      (else (error "ha! funny"))))
  dispatch)


(define (loop amb-var proc)
  (let ((x (amb-var 'next)))
    (if (null? x)
        '()
        (cons (cons x (proc x))
              (loop amb-var proc)))))

(loop (amb '(1 2 3 4))
      (lambda (baker)
        (loop (amb '(2 3 4 5))
              (lambda (cooper)
                (loop (amb '(2 3 4))
                      (lambda (x)
                        (list x)))))))
(loop (amb '(1 2 3 4))
      (lambda (baker)
        (cons baker
              (loop (amb '(2 3 4 5))
                    (lambda (cooper)
                      (cons cooper
                            (loop (amb '(2 3 4))
                                  (lambda (x)
                                    (cons x 'ha)))))))))


(define (multiple-dwelling)
  (let ((baker    (amb 1 2 3 4)))
    (let ((cooper (amb 2 3 4 5)))
      (let ((fletcher (amb 2 3 4)))
        (require (not (= (abs (- fletcher cooper)) 1)))
        (let ((miller (amb 1 2 3 4 5))
              (smith    (amb 1 2 3 4 5)))
          (require (> miller cooper))
          (require (not (= (abs (- smith fletcher)) 1)))
          (require (distinct? (list baker cooper fletcher miller smith)))
          (list (list 'baker baker)       (list 'cooper cooper)
                (list 'fletcher fletcher) (list 'miller miller)
                (list 'smith smith)))))))