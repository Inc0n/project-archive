
(define (mlist . items) (foldr mcons '() items))

(define empty-tree? null?)
(define (entry tree) (mcar tree))
(define (left-branch tree) (mcdr tree))
(define (right-branch tree) (mcdr (mcdr tree)))
(define (make-tree entry (left '()) (right '()))
  (mlist entry left right))

(define (make-record key value)
  (mcons key value))
(define (record-key record) (mcar record))
(define (record-value record) (mcdr record))

(define (adjoin-set x set)
  (cond ((null? set) (make-tree x '() '()))
        ((< (car x) (car (entry set)))
         (let (left (left-branch set))
           (set! left (adjoin-set x left))))
        ((> (car x) (car (entry set)))
         (let (right (right-branch set))
           (set right (adjoin-set x right))))))

(define (adjoin-set x set)
  (cond ((null? set) (make-tree x '() '()))
        ((equal? (record-key x) (record-key (entry set)))
         (set-mcar! set x))
        ((symbol<? (record-key x) (record-key (entry set)))
         (if (null? (left-branch set))
             (set-mcar! (mcdr set) (make-tree x '() '()))
             (adjoin-set x (left-branch set))))
        (else
         (if (null? (right-branch set))
             (set-mcar! (mcdr (mcdr set)) (make-tree x '() '()))
             (adjoin-set x (right-branch set))))))

(define (lookup key records)
  (cond ((null? records)
         false)
        ((equal? key (mcar (mcar records)))
         (mcar records))
        ((symbol<? key (mcar (mcar records)))
         (lookup key (left-branch records)))
        (else
         (lookup key (right-branch records)))))

(define (make-table)
  (define (assoc key set not-found-proc equal-proc inequal-proc)
    (define (assoc-1 key set)
      (cond ((null? set)
             (not-found-proc))
            ((equal? key (record-key (entry set)))
             (equal-proc set))
            ((symbol<? key (record-key (entry set)))
             (inequal-proc assoc-1 (left-branch set)))
            (else
             (inequal-proc assoc-1 (right-branch set)))))
    (assoc-1 key set))
  (let ((local-table '()))
    (define (print)
      (printf "~a~%" local-table))
    (define (lookup key)
      (assoc key local-table
             (lambda () #f)
             (lambda (set) (mcar set))
             (lambda (assoc-1 branch) (assoc-1 key (mcar branch)))))
    (define (insert! key value)
      (if (null? local-table)
          (set! local-table (make-tree (make-record key value)
                                       '() '()))
          (assoc key local-table
                 (lambda ()
                   (make-tree (make-record key value) '() '()))
                 (lambda (set)
                   (set-mcar! set (make-record key value)))
                 (lambda (assoc-1 branch)
                   (set-car! branch (assoc-1 key (mcar branch)))))))
    (define (dispatch m)
      (cond ((eq? m 'lookup) lookup)
            ((eq? m 'insert!) insert!)
            ((eq? m 'print) print)
            (else (error "Unknown operation: TABLE" m))))
    dispatch))

;; (define (lookup key)
;;       (define (iter tree)
;;         (cond ((null? tree) false)
;;               (else
;;                (let ((node (entry tree))
;;                      (left (left-branch tree))
;;                      (right (right-branch tree)))
;;                  (cond ((= key (record-key node)) (record-value node))
;;                        ((< key (record-key node)) (iter left))
;;                        ((> key (record-key node)) (iter right)))))))
;;       (iter local-table))
;;     (define (insert! key value)
;;       (define (iter tree)
;;         (cond ((null? tree) (make-tree (make-record key value) '() '()))
;;               (else
;;                (let ((node (entry tree))
;;                      (left (left-branch tree))
;;                      (right (right-branch tree)))
;;                  (cond ((= key (record-key node))
;;                         (set-value! node value)
;;                         tree)
;;                        ((< key (record-key node))
;;                         (make-tree node (iter left) right))
;;                        ((> key (record-key node))
;;                         (make-tree node left (iter right))))))))
;;       (set! local-table (iter local-table)))
