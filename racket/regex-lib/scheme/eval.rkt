
(require "lexi.rkt"
         "stream-oop.rkt"
         "operation-table.rkt")

(define (stream-next stm) ((stm 'read-char) 'done))

(define (install-re-eval)
  ;;
  (define (re/star c)
    (define (aux stm next-c)
      (if (not (c stm next-c))
          ((stm 'back-char))
          (aux stm ((stm 'read-char)))))
    (lambda (stm next-c)
      (aux stm next-c)
      #t))
  (define (re/plus c)
    (let ((f (re/star c)))
      (lambda (stm next-c)
        (let ((start (stm 'index)))
          (f stm next-c)
          (> (stm 'index) start)))))
  (define (re/question c)
    (lambda (stm next-c)
      (if (not (c stm next-c))
          ((stm 'back-char))
          '())
      #t))
  (define (re/bar c)
    (let ((cond1 (car c))
          (cond2 (cadr c)))
      (lambda (stm next-c)
        (or (cond1 stm next-c)
            (cond2 stm next-c)))))
  (define (re/char c)
    (lambda (stm next-c)
      (char=? c next-c)))
  ;;
  (define-syntax-rule (put-re/eval key1 key2 (arg) f)
    (put key1 key2
         (lambda (arg) f)))
  (put 'eval 'char re/char)
  (put 'eval #\\   re/char)
  (put-re/eval 'eval #\. (c)
               (lambda (stm next-c) #t))
  (put-re/eval 'eval #\^ (c)
               (lambda (stm next-c) (= (stm 'index) 1)))
  (put-re/eval 'eval #\$ (c)
               (lambda (stm next-c) (eq? next-c 'done)))
  (put-re/eval 'eval #\[ (c)
               (lambda (stm next-c) (memq next-c c)))
  (put-re/eval 'eval #\{ (c)
               (lambda (stm next-c) next-c))
  (put-re/eval 'eval #\( (c)
               (lambda (stm next-c) c))
  (put 'eval #\* re/star)
  (put 'eval #\+ re/plus)
  (put 'eval #\? re/question)
  (put 'eval #\| re/bar)
  ;;
  'done)

(define (atom? x)
  (and (not (null? x))
       (not (pair? x))))

(install-re-eval)

(define (compile-re lexed-re)
  (if (pair? lexed-re)
      (cond ((atom? (car lexed-re))
             (let ((eval-proc (get 'eval (car lexed-re))))
               (if eval-proc
                   (eval-proc (compile-re (cdr lexed-re)))
                   (error "unhanled regex expr: COMPILE-RE"
                          (car lexed-re)))))
            ((pair? (car lexed-re))
             (map compile-re lexed-re)))
      lexed-re))

(define (run-eval re-str str)
  (install-re-eval)
  (define (aux re stm)
    (let ((next-c (stream-next stm)))
      (cond ((eq? next-c 'done) #f)
            ((null? (cdr re))
             ((car re) stm next-c))
            (((car re) stm next-c)
             (aux (cdr re) stm))
            (else #f))))
  (define (regex re stm idx)
    (aux (compile-re re) stm))
  (let ((stm (make-string-stream str)))
    (regex (analysis re-str) stm 0)))